#!/usr/bin/env ruby
require 'json'
require 'net/http'
require 'optparse'
require 'serialport'

# Noop Logger
class Logger

  def debug(message)
    write message
  end

  def error(message)
    write message
  end

  def info(message)
    write message
  end

  def write(message)
  end
end

class ConsoleLogger < Logger
  def write(message)
    puts message
  end
end

class HitReader
  BAUD_RATE = 9600 # this is required by the device
  # Any of the other button presses are not valid zones
  BUTTON_ZONE_MAP = {
    16 => 1,
    32 => 2,
    64 => 3,
  }

  attr_reader :host_url, :logger

  def initialize(logger)
    @logger = logger
  end

  def setup(device_path, host_url = nil)
    @dongle = init_dongle device_path
    @logger.info "Initialized Port: #{device_path}"
    @host_url = host_url
    if @host_url == ''
      @logger.info "Hit Target Url: #{host_url}"
    end
  end

  def run
    last_hit = {esn: '', zone: 0, hit_matcher: 0}
    loop do
      IO.select([@dongle])
      button, esn = get_message(@dongle, 5)

      # the keyfob includes alternate button states
      # we do not use, so ignore them.
      next unless BUTTON_ZONE_MAP.include? button

      hit = build button, esn

      next if hit.eql? last_hit # avoid "hold" presses counting as multiple hits

      last_hit = hit.clone
      @logger.debug JSON.dump hit
      send hit
    end
  end

  def init_dongle(path)
    SerialPort.new path, BAUD_RATE
  rescue Errno::ENOENT => e
    @logger.error e.message
    exit false
  end

  def get_message(io_dev, size)
    message = ''
    len = message.length
    while len < size
      chunk = io_dev.read(size - len)
      # error checking on chunk value
      message += chunk
      len = message.length
    end
    return message.unpack('CH8')
  end

  def send(hit)
    return nil if @host_url == ''

    uri = URI(@host_url)
    hit.delete('hit_matcher')
    hit['time'] = Time.now
    res = Net::HTTP.post_form(uri, hit)
    @logger.debug res.body
  end

  def build(button, esn)
    # quarter: (Time.now.to_f / 0.25).round * 0.25
    r = (Time.now.to_f * 2).round / 2.0
    hit_matcher = r == r ? r.to_i : r
    { esn: esn,
      zone: BUTTON_TO_ZONE_MAP[button],
      hit_matcher: hit_matcher
      zone: BUTTON_ZONE_MAP[button],
    }
  end
end

logger = ConsoleLogger.new
hr = HitReader.new logger
hr.setup ARGV[0], ARGV[1]
hr.run
